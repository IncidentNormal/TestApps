'''
Created on Sep 15, 2010

@author: duncantait
'''
from SimPy.SimulationRT import *
import numpy as np
import random
import string
from whrandom import choice
import math

#Global, simulation settings
class G():
    """Global, simulation settings"""
    num_channels = 10
    num_stations = 3
    max_time = 10000

#Container class for the Network of stations
class Network():
    stations = []
  
#Medium that the signal is propagating through
class Medium():
    def __init__(self):
        self.channels = [] #A Store for each channel
        self.channel_in_use = [] #Boolean values for each channel - whether in use or not (not currently used)
        self.channel_events = [] #Event added for each channel, fired when channel becomes in use
        for i in range(G.num_channels):
            S = Store(name=i,capacity=1)
            self.channels.append(S) 
            V = False
            self.channel_in_use.append(V)
            sE = SimEvent(name=i)
            self.channel_events.append(sE)

#A framework that contains other class instances that all form parts of the station
class StationContainer():
    def __init__(self,ID):
        self.ID = ID
        self.Operations = Operations(ID) #Instantiate classes that are parts of the station
        self.MetaStation = MetaStation(ID)
        self.Scanner = Scanner(ID)
        self.HandShake = HandShake(ID)
        self.Tx = Tx(ID)
        self.FrameMaker = FrameMaker(ID)
    def initComponents(self):
        self.Operations.initComponents() #Run various custom constructors for these classes
        self.Scanner.initComponents()
        self.Tx.initComponents()
        self.HandShake.initComponents()
        self.FrameMaker.initComponents()
    def activate(self):
        activate(self.Operations,self.Operations.operating(),at=0.0) #Activate all these classes in SimPy
        activate(self.Scanner,self.Scanner.scanning(),at=0.0)
        activate(self.HandShake,self.HandShake.handshake(),at=0.0)
        activate(self.Tx,self.Tx.sending(),at=0.0)

#Contains details and variables of the station reflecting current state
#Referenced by other classes making up the station
class MetaStation():
    def __init__(self, ID):
        self.ID = ID
        self.Name = self.genName() #Name in ALE format generated by function to be in a valid format
        
        self.Mode = sState.SCANNING #Mode - either SCANNING, LINKING or LINKED
        self.Transmitting = False #Whether station is currently transmitting
        self.currentChannel = random.randint(0,G.num_channels-1) #Current channel station is scanning
        self.LinkedChannel = -1 #Current channel station is linked on (not currently in use)
        self.LinkedID = -1 #Current station this station is linked to
        #Matrix of BER's on all channels for each station (will be number between 0 and 1):
        self.channelBER = np.zeros((G.num_stations,G.num_channels)) #LQA: Link Quality Analysis
        for i in range(len(self.channelBER)):
            for j in range(len(self.channelBER[i])):
                    self.channelBER[i,j] = random.random() #Start with a random number for each value
        
        self.minLQA = 0.2 #Lowest LQA allowable (any lower and link will be assumed to fail)
        
        self.lastMessageRec = '' #copies of last last received
        self.lastMessageSent = '' #and sent
        
        self.Trw = 2 #all in sec
        self.Td = 2. #dwell time per channel
        self.Twce = 2*self.Td*G.num_channels #wait for calling cycle to end
        self.Twr = 2
        self.hardwareTime = 0 #tiny increment of time to reflect hardware
        self.bitrate = 392. #bps (this needs to be re-evaluated and made more detailed, as this is max possible)
        
        self.timeout = 2. #current timeout for scan when in Linking/Linked mode. In Scanning mode it = Td
        
        self.HandShake_Signal = SimEvent(name='handshake') #Various events between HandShake and Scanner classes
        self.Response_Done = SimEvent(name='response') #Signify when certain things have happened
        self.Ack_Done = SimEvent(name='ack')
        self.Tx_Signal = SimEvent(name='TxStart')
        self.Transmission_Done = SimEvent(name='TxDone') #This will be fired from Tx
    
    def genName(self): #Name is generated here, 1-15 chars from the full alphanumeric range
        chars = string.letters + string.digits
        name = ''
        for i in range(random.randint(1,15)):
            name +=  choice(chars)
        return name

#What an operator would do: Make calls to establish links.
#Send data if Linked
class Operations(Process): 
    def __init__(self,ID):
        Process.__init__(self)
        self.ID = ID
        #Probabilities of making different types of call
        self.probAMD = 0.5
        self.probDTM = 0.2
        self.probDBM = 0.1
        self.probNone = 0.5
        self.probTerminate = 0.2
        
        self.probConnect = 0.5 #???????????????
        
        self.timeToWait = 10. #Average time to wait between calls (in seconds)
        
    def initComponents(self):
        self.MetaStation = [N.MetaStation for N in Network.stations if N.ID==self.ID][0]
        self.Tx = [N.Tx for N in Network.stations if N.ID==self.ID][0]
        self.FrameMaker = [N.FrameMaker for N in Network.stations if N.ID==self.ID][0]
    def operating(self):
        while True:
            yield hold, self, random.uniform(0,60) #This ultimately needs to be deleted in favour of the timeToWait variable
            if self.MetaStation.Mode==sState.LINKED and self.MetaStation.Transmitting==False:
                #choose message type to send to linked person/terminate
                returnFrame = frameDetails()
                
                probs = [self.probAMD, self.probDTM, self.probDBM, self.probNone]
                norm = []   
                for x in probs:
                    norm.append(x/(self.probAMD + self.probDTM + self.probDBM + self.probNone))
                if random.random()> norm[0]: #Randomly select type of data
                    returnFrame.dataBlock = dType.AMD
                elif random.random()> sum(norm[0:2]):
                    returnFrame.dataBlock = dType.DTM
                elif random.random()> sum(norm[0:3]):
                    returnFrame.dataBlock = dType.DBM
                elif random.random()> sum(norm[0:4]):
                    returnFrame.dataBlock = dType.none
                    
                if random.random()> self.probTerminate:
                    returnFrame.terminate = True
                
                #timeToWait is a ballpark figure of how long to leave between messages,
                #idea is it can change depending on the type of message last send
                #not to be confused with timeout, which is how long the Scanner class
                #waits on a channel for a signal to appear before moving on (and 
                #possibly cancelling LINKING/LINKED mode)
                if returnFrame.dataBlock==dType.DBM: self.timeToWait=random.expovariate(1./30.) #Time to wait before sending next message
                if returnFrame.dataBlock==dType.DTM: self.timeToWait=random.expovariate(1./30.)
                if returnFrame.dataBlock==dType.AMD: self.timeToWait=random.expovariate(1./30.)
                
                #Create a basic outline of what the Frame to send will be, then send to FrameMaker class
                #to flesh it out properly
                returnFrame.channels = [self.MetaStation.LinkedChannel]
                returnFrame.destination = self.MetaStation.LinkedStation
                returnFrame.origin = self.ID
                returnFrame = self.FrameMaker.entryPoint(returnFrame)
                
                print self.ID, 'sending MSG to station', returnFrame.destination, now()
                #Put the frame into the Tx class's send queue.
                yield put, self, self.Tx.sendQ, [returnFrame]
            
            if self.MetaStation.Mode==sState.SCANNING and self.MetaStation.Transmitting == False:
                #choose who to connect to and who to call
                self.MetaStation.mode = sState.LINKING #Changes to Linking mode
                returnFrame = frameDetails()
                returnFrame.type = fType.CALL
                returnFrame.destination = self.decideDestination()
                returnFrame.origin = self.ID
                returnFrame.channels = self.ChannelOrder(returnFrame.destination)
                returnFrame.terminate = False
                
                returnFrame = self.FrameMaker.entryPoint(returnFrame)
                
                print self.ID, 'sending CALL to station', returnFrame.destination, 'on channel', returnFrame.channels, now()
                yield put, self, self.Tx.sendQ, [returnFrame]
                #self.MetaStation.Mode = sState.LINKING
                self.MetaStation.timeout = self.MetaStation.Twce #Set scanning timeout to a longer time to reflect the long length of the leading call
  
            yield hold, self, self.timeToWait #wait for a random amount of time between calls
            
    def decideDestination(self): #Randomly chooses a destination that isn't itself
        while True:
            dest = random.randint(0,G.num_stations-1)
            if dest != self.ID:
                return dest
    def ChannelOrder(self,station): 
        #sorts best channels best-worst in terms of LQA and returns an array
        ordered = self.MetaStation.channelBER[station,:].argsort()
        return ordered[::-1] #reverse order of array
                          
#Kind of an Rx class, scans all channels in sequence until it finds a message addressed to itself
class Scanner(Process):
    def __init__(self,ID):
        Process.__init__(self)
        self.ID = ID
    def initComponents(self):
        self.MetaStation = [N.MetaStation for N in Network.stations if N.ID==self.ID][0]
        self.Tx = [N.Tx for N in Network.stations if N.ID==self.ID][0]
    def scanning(self):
        if now()==0.0: yield hold, self, random.random() #Make sure they don't all start at exactly the same time
        
        def forMe(chan): #A filter function for the SimPy 'get' from Store.
            """filter: return only if addressed to me"""
            for i in chan:
                if i.destination==self.ID:
                    return [i]
        while True:   
            channel = Medium.channels[self.MetaStation.currentChannel] #Reference to corresponding channel SimPy Store
            print self.ID, 'SCANNING CHANNEL', self.MetaStation.currentChannel, now()
            yield (get,self,channel,forMe),(hold,self,self.MetaStation.timeout) #Only gets the packet if it's addressed to this station
            
            acquired = self.acquired(channel) #acquired is True if it successfully got a packet before timing out
            print self.ID, 'On channel:', self.got, 'self.acquired=', acquired, now()
            if self.MetaStation.Transmitting:                                       #This if statement is to make sure that if Operator or HandShake makes Tx start transmitting while 
                print self.ID, 'transmitting, so skipping to bottom of PEM', now()  #scanning a channel, it will stop scanning after the wait, and if it found anything it will replace
                if acquired:                                                        #it and move to the bottom of this PEM where it will be paused until the transmission is over.
                    print self.ID, 'acquired packet accidentally, replace on channel immediately', now()
                    yield put, self, channel, self.got                           
                    print self.ID, 'packet replaced', now()
            elif acquired:  #If it did actually acquire a packet, proceed:
                print self.ID, 'message received on channel', self.MetaStation.currentChannel, now() 
                frameInfo = self.got[0]
                print self.ID, 'got this off channel', self.MetaStation.currentChannel, frameInfo, now()
                yield put, self , channel, [frameInfo]  

                if (frameInfo.LQA > self.MetaStation.minLQA) and (frameInfo.destination==self.ID): #Establish it is addressed to this station and above minimum LQA.
                    self.MetaStation.Mode = sState.LINKING #Enter Linking mode
                    print self.ID, '*message for me!!', now()
                    yield (put,self,channel,['PH:'+str(self.ID)]),(hold,self,self.MetaStation.Twce) #To check when the channel becomes free (origin station end's it's scanning call)
                    stored = self.stored(channel) #Try to place a packet into the channel, when it becomes free this will automatically proceed.
                    print self.ID, 'placeholder placed on channel', self.MetaStation.currentChannel, now()
                    if self.MetaStation.Transmitting: #Same purpose as above (13 lines up)
                        print self.ID, 'Transmitting whilst trying to store placeholder', now()
                        if stored:
                            print self.ID, 'Managed to store packet to grab it off straightaway; as transmitting', now()
                            yield get, self, channel, 1, 5 # '5' is priority (higher than basic scan)
                            print self.ID, 'sniffing packet removed', now()
                    elif stored: 
                        print self.ID, 'not transmitting & about to Yank sniffer packet', now()
                        yield get,self,channel,1 #Yank sniffer packet back off channel.
                        print self.ID, '**signal finished!, (sniffer packet yanked) from station', frameInfo.origin
                        self.MetaStation.lastMessageRec = frameInfo
                        
                        if frameInfo.type == fType.CALL:
                            print self.ID, 'CALL from station', frameInfo.origin
                            self.MetaStation.mode = sState.LINKING
                            self.MetaStation.HandShake_Signal.signal('call')
                            print self.ID, 'WAITING FOR RESPONSE TO BE DONE', now()
                            yield waitevent, self, self.MetaStation.Response_Done
                            print self.ID, 'Response done signal received', now()
                        if frameInfo.type == fType.RESPONSE and self.MetaStation.mode == sState.LINKING:
                            print self.ID, 'RESPONSE from station', frameInfo.origin
                            self.MetaStation.HandShake_Signal.signal('resp')
                            print self.ID, 'WAITING FOR ACK TO BE DONE', now()
                            yield waitevent, self, self.MetaStation.Ack_Done
                            print self.ID, 'Ack done signal received', now()
                        if frameInfo.type == fType.ACK and self.MetaStation.mode == sState.LINKING:
                            print self.ID, 'ACK RECEIVED FROM STATION', frameInfo.origin, 'LINKED', now()
                            self.MetaStation.mode = sState.LINKED
                        if frameInfo.dataBlock!=dType.none:
                            print self.ID, 'Data Block received:', frameInfo.dataBlock, now()
                        if frameInfo.terminate==True:
                            print self.ID, 'terminate signal received', now()
                            self.MetaStation.mode = sState.SCANNING
                    else:
                        print self.ID, 'Timed out waiting for message to finish', now()
                        self.MetaStation.mode = sState.SCANNING #Timed out waiting for message to finish
                else:
                    print self.ID, 'SHOULD NOT BE HERE IF LQA IS ABOVE 0.2' , now()
                    print self.ID, 'Packet was of insufficient quality / for someone else.. LQA / destination:', frameInfo.LQA, frameInfo.destination, now()
                    self.MetaStation.mode = sState.SCANNING #Packet wasn't of sufficient quality or for someone else
            else:
                print self.ID, 'Not transmitting and timed out' ,self.MetaStation.currentChannel,', timeout currently =', self.MetaStation.timeout, now()
                self.MetaStation.mode = sState.SCANNING #Timed out waiting for response/ack etc.
            
            if self.MetaStation.Transmitting==True:
                print self.ID, 'WAITING FOR TRANSMISSION TO END', now()
                yield waitevent,self,self.MetaStation.Transmission_Done
                print self.ID, 'Transmission_Done event received, mode=', self.MetaStation.Mode, now()
                #Will only be sending if in linking or linked mode.

            if self.MetaStation.mode==sState.SCANNING: #Cycles through channels if in Scanning mode.   
                self.MetaStation.LinkedID = -1 #Cleans house on 'Linked only' variables
                self.MetaStation.LinkedChannel = -1
                self.MetaStation.timeout = self.MetaStation.Td
                if self.MetaStation.currentChannel==G.num_channels-1: 
                    self.MetaStation.currentChannel = 0
                else:
                    self.MetaStation.currentChannel+=1
                
# This class facilitates the handshaking process, upon receiving the 'HandShake_Signal' it activates
class HandShake(Process):
    def __init__(self,ID):
        Process.__init__(self)
        self.ID = ID
    def initComponents(self):
        self.MetaStation = [N.MetaStation for N in Network.stations if N.ID==self.ID][0]
        self.Tx = [N.Tx for N in Network.stations if N.ID==self.ID][0]
        self.FrameMaker = [N.FrameMaker for N in Network.stations if N.ID==self.ID][0]
    def handshake(self):
        while True:
            yield waitevent, self, self.MetaStation.HandShake_Signal
            print self.ID, 'HandShake signal activated', now()
            returnFrame = frameDetails()
            returnFrame.destination = self.MetaStation.lastMessageRec.origin
            returnFrame.origin = self.ID
            returnFrame.channels = [self.MetaStation.currentChannel]
            call_resp = self.MetaStation.HandShake_Signal.signalparam
            if call_resp=='call':
                returnFrame.type = fType.RESPONSE
                returnFrame = self.FrameMaker.entryPoint(returnFrame)
                yield put, self, self.Tx.sendQ, [returnFrame]
                yield waitevent, self, self.MetaStation.Transmission_Done #Surely it can get stuck here - need a way of reactivating the class if necessary
                if self.MetaStation.Transmission_Done.signalparam.type == fType.RESPONSE: #Quick check the packet is the same
                    print self.ID, 'RESPONSE SENT!!!', now()
                    self.MetaStation.Response_Done.signal()
                    self.MetaStation.timeout = self.MetaStation.Twr
                else: 
                    print self.ID, 'wrong packet! (R)', now()
            elif call_resp=='resp':
                print self.ID, 'readying ACK to send to Tx'
                returnFrame.type = fType.ACK
                returnFrame = self.FrameMaker.entryPoint(returnFrame)
                yield put, self, self.Tx.sendQ, [returnFrame]
                print self.ID, 'sent to Tx'
                yield waitevent, self, self.MetaStation.Transmission_Done
                if self.MetaStation.Transmission_Done.signalparam.type == fType.ACK:
                    print self.ID, 'ACK SENT!!!!'
                    self.MetaStation.Ack_Done.signal
                    self.MetaStation.mode = sState.LINKED
                else: 
                    print 'wrong packet! (A)'               
                #self.MetaStation.Ack_Done.signal
                #self.MetaStation.mode = sState.LINKED
            
            
class Tx(Process):
    def __init__(self,ID):
        Process.__init__(self)
        self.ID = ID
        self.sendQ = Store(name=ID,capacity='unbounded')
    def initComponents(self):
        self.MetaStation = [N.MetaStation for N in Network.stations if N.ID==self.ID][0]
        self.Scanner = [N.Scanner for N in Network.stations if N.ID==self.ID][0]
    def sending(self):
        while True:
            yield get,self,self.sendQ,1
            frameInfo = self.got[0] #data in form frameDetails()
            print self.ID, 'Tx received packet of type', frameInfo.type, now()
            signal_time = frameInfo.size/self.MetaStation.bitrate + self.MetaStation.hardwareTime
            print 'signal_time=', frameInfo.size, 'divide', self.MetaStation.bitrate, '=', signal_time
            frameInfo.LQA = self.calculate_LQA(frameInfo.destination)
            
            unSent = True
            for chanNum in frameInfo.channels:
                if unSent:
                    channel = Medium.channels[chanNum]
                    if channel.nrBuffered==0:
                        print self.ID, 'channel', chanNum, 'free. Sending to station', frameInfo.destination, now()
                        self.MetaStation.Transmitting = True
                        self.MetaStation.Tx_Signal.signal()
                        yield put,self,channel,[frameInfo]
                        unSent = False

                        self.MetaStation.currentChannel = chanNum #Update linked information
                        #SHOULD THIS BE CURRENTCHANNEL OR LINKEDCHANNEL? SHOULD THERE BE A DISTINCTION?
                        self.MetaStation.LinkedID = frameInfo.destination
                        
                        print self.ID, 'about to occupy channel', chanNum, 'for', signal_time, now()
                        yield hold, self, signal_time
                        print self.ID, 'waited for allocated signal time, attempting to remove signal from chan', now()
                        if self.interrupted():
                            print 'Collision Occurred' #No provision for this yet.
                        
                        yield get,self,channel,1 #Message delivered.
                        print self.ID, 'signal removed successfully', now()
                        yield hold, self, self.MetaStation.hardwareTime #wait for a tiny bit so it doesnt IMMEDIATELY start scanning and grab something off channel.
                        #In future this will be exacerbated by the propagation delay etc.
                        self.MetaStation.Transmitting = False
                        print self.ID, ': TRANSMISSION COMPLETED, SENDING EVENT', frameInfo.type, now()
                        self.MetaStation.lastMessageSent = frameInfo
                        self.MetaStation.Transmission_Done.signal(frameInfo)
                        print self.ID, 'event sent', now()
                    else:
                        #INFINITE LOOP?! WHAT IF IT GETS HERE AND HAS 1 CHANNEL?
                        print self.ID, 'channel taken', [(i.origin,i.destination,i.type,i.channels) for i in channel.theBuffer], now() 
                        
    def calculate_LQA(self, destination):
        #This algorithm has potential to be highly detailed
        #Parameters needed: positions of 2 stations --> distance
        #Ionospheric conditions
        #Time of day, sunspot cycle.
        #For now, stations closer in numbers are better connected.
        #This should be in Tx as it needs to eventually interface with an Environment process
        distance = abs(self.ID - destination)/G.num_stations
        LQA = random.normalvariate(100-(distance*100),4)
        if LQA > 1: LQA=1
        if LQA < 0: LQA=0
        return LQA               
        
#Framemaker: Takes parameters from either Operator or Handshake and creates a frame to be sent.
#The parameters are explicit, the framemaker merely constructs the frame and randomises size of payloads etc. 
class FrameMaker():
    def __init__(self,ID):
        self.ID = ID
    def initComponents(self):
        self.MetaStation = [N.MetaStation for N in Network.stations if N.ID==self.ID][0]
    def entryPoint(self, frameDetails):
        returnFrame = frameDetails
        self.leadingCall = 2*self.address_length(returnFrame.destination) + self.address_length(returnFrame.origin)
        if returnFrame.type == fType.CALL:
            returnFrame = self.ScanningCall(returnFrame)
        if (returnFrame.type == fType.ACK) or (returnFrame.type == fType.RESPONSE):
            returnFrame = self.AckResponse(returnFrame)
            
        if returnFrame.dataBlock == dType.AMD:
            returnFrame = self.AMD(returnFrame)
        elif returnFrame.dataBlock == dType.DTM:
            returnFrame = self.DTM(returnFrame)
        elif returnFrame.dataBlock == dType.DBM:
            returnFrame = self.DBM(returnFrame)
        elif returnFrame.dataBlock == 0: #Randomise dataBlock
            probAMD = 0.2
            if random.random() < probAMD:
                returnFrame = self.AMD(returnFrame)
        
        if returnFrame.terminate == -1:
            probTerminate = 0.1
            if random.random() < probTerminate:
                returnFrame.terminate = True
                    
        return returnFrame
    def ScanningCall(self, frame):
        returnFrame = frame
        returnFrame.size = (self.MetaStation.Td*G.num_channels*self.MetaStation.bitrate) #This is a bit of a cheat but should work...
        return returnFrame
    def AckResponse(self, frame):
        returnFrame = frame
        returnFrame.size = self.leadingCall
        return returnFrame
    def Message(self, frame):
        returnInfo = frame
        if frame.dataBlock==dType.DBM: #Make a class of these
            returnInfo = self.DBM(returnInfo)
        elif frame.dataBlock==dType.DTM:
            returnInfo = self.DTM(returnInfo)      
        elif frame.dataBlock==dType.AMD:
            returnInfo = self.AMD(returnInfo)
        return returnInfo
    def AMD(self,frameInfo):
        #maximum 30 words
        frameInfo.size += random.randint(1,30)*24
        return frameInfo   
    def DTM(self,frameInfo):
        if random.random() > 0.5: #50/50 chance of being BASIC or EXTENDED mode
            frameInfo.size += random.randint(1,93)*7
        else:
            frameInfo.size += random.randint(3,1053)*7 +24
    def DBM(self, frameInfo):
        if random.random() > 0.5:
            frameInfo.size += random.randint(1,81)*7 + 16
        else:
            frameInfo.size += random.randint(82,37260)*7 + 16 + 24 
    
    def address_length(self, address):
        return math.ceil(len(Network.stations[address].MetaStation.Name)/3)*24

                    
class frameDetails():
    def __init__(self, origin=-1, destination=-1, size=0, dataBlock=0, type=0, cmd_type=0, terminate=-1, channels=[], LQA=-1):
        self.origin = origin #who sent it
        self.destination = destination #where its going
        self.size = size #size in bits of the entire frame
        self.dataBlock = dataBlock #type of datablock if any (AMD,DTM,DBM) (0 if not)
        self.type = type #type of frame if special (CALL,RESPONSE,ACK,MSG,CMD) --MSG is a single message
        self.cmd_type = cmd_type #type of CMD if frame was a CMD frame (0 if not)
        self.terminate = terminate #whether frame ends in TWAS and hence breaks link
        self.channels = channels #channel(s) to deliver frame via
        self.LQA = LQA #LQA value of received frame from 0-1
        
class fType():
    MSG = 1
    CALL = 2
    RESPONSE = 3
    ACK = 4
    CMD = 5
    
class dType():
    DBM = 1
    DTM = 2
    AMD = 3
    none = 4
    
class cType():
    LQA = 1
    MODE = 2
    SCHEDULE = 3
    
class sState():
    SCANNING = 1
    LINKING = 2
    LINKED = 3
    
class visualisations():
    def __init__(self,ID):
        self.ID = ID

initialize()

Medium = Medium()

Network.stations = [StationContainer(i) for i in range(G.num_stations)]
for N in Network.stations:
    N.initComponents()
    N.activate()
simulate(until=G.max_time, real_time=True, rel_speed=1)
print '** Fin'
            
            